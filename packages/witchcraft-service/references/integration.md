# Witchcraft Service — Integration Architecture

> Part of the witchcraft-service workflow. See [SKILL.md](../SKILL.md) for overview.

## Table of Contents
- [Shared Foundation](#shared-foundation)
- [Enchant → Cherry Integration](#enchant--cherry-integration)
- [Enchant → Rune Integration](#enchant--rune-integration)
- [Transmute → Enchant Integration](#transmute--enchant-integration)
- [Cherry Observability Stack](#cherry-observability-stack)
- [Data Flow Architecture](#data-flow-architecture)
- [Dependency Graph](#dependency-graph)

## Shared Foundation

All Witchcraft stack tools share the same serialization foundation:

```
attrs (data classes)
  └── cattrs (structured ↔ unstructured conversion)
        ├── Rune (@inscribed → attrs class + validation)
        ├── Enchant (generated models → attrs classes)
        └── Transmute (source/target schemas → attrs classes)
```

This means:
- Rune-validated models are directly usable as Enchant type implementations
- Transmute migration schemas are compatible with Enchant-generated models
- A single `cattrs.Converter` can handle all three

## Enchant → Cherry Integration

Enchant generates server stubs that register on Cherry's `Router`:

```python
# Generated by: enchant build --server
class CatalogServiceBase:
    """Abstract base — implement in your code."""

    def register(self, router: Router):
        """Registers all endpoints on the Cherry router."""
        router.post("/api/catalog/products", self._handle_create_product)
        router.get("/api/catalog/products", self._handle_list_products)
        router.get("/api/catalog/products/{productId}", self._handle_get_product)

    def _handle_create_product(self):
        """Extracts params, deserializes body, calls your implementation."""
        body = read_request_body()
        request = read_body(body, CreateProductRequest, self._converter)
        result = self.create_product(request)
        return json_response(result, converter=self._converter, status=201)
```

### Error mapping

Enchant errors map to Cherry's `EnchantServiceException`:

| Enchant error code | HTTP status | Cherry exception |
|-------------------|-------------|-----------------|
| `NOT_FOUND` | 404 | `EnchantServiceException(error_code="NOT_FOUND")` |
| `INVALID_ARGUMENT` | 400 | `EnchantServiceException(error_code="INVALID_ARGUMENT")` |
| `PERMISSION_DENIED` | 403 | `EnchantServiceException(error_code="PERMISSION_DENIED")` |
| `CONFLICT` | 409 | `EnchantServiceException(error_code="CONFLICT")` |

Cherry's `enchant_error_handler_middleware` catches these and serializes to Conjure wire format:

```json
{
    "errorCode": "NOT_FOUND",
    "errorName": "CatalogService:ProductNotFound",
    "errorInstanceId": "uuid",
    "parameters": {"productId": "42"}
}
```

### Safety annotations flow

```
.enchant.yml: safety: safe/unsafe/do-not-log
  → Generated models: Annotated[str, SafeArg] / Annotated[str, UnsafeArg]
    → Cherry middleware: svc1log.safe_param() / svc1log.unsafe_param()
      → structlog: plaintext in dev, REDACTED in production
```

## Enchant → Rune Integration

Enchant generates attrs models. Rune's `@inscribed` adds validation on top:

```python
# Option 1: Use Enchant-generated models directly (no extra validation)
from catalog.generated.models import CreateProductRequest
# attrs class with cattrs serialization, no runtime validation

# Option 2: Augment with Rune constraints
from rune import inscribed
from rune.constraints import MinLen, MaxLen, Gt

@inscribed
class CreateProductRequest:
    """Rune-validated version with runtime constraints."""
    name: Annotated[str, MinLen(1), MaxLen(255)]

# Option 3: Use Rune for internal models, Enchant for API boundary
# Enchant handles wire format, Rune handles business rules
```

### When to use which

| Scenario | Use |
|----------|-----|
| API request/response types | Enchant-generated models (wire format compliance) |
| Internal domain models | Rune `@inscribed` (rich validation) |
| Database/persistence models | Rune `@inscribed` (constraints match DB schema) |
| API boundary with validation | Enchant model + Rune `.validate()` in handler |

### Combining at the boundary

```python
from rune import inscribed
from catalog.generated.models import CreateProductRequest as WireRequest

@inscribed
class ValidatedCreateProduct:
    name: Annotated[str, MinLen(1), MaxLen(255)]

class CatalogServiceImpl(CatalogServiceBase):
    async def create_product(self, request: WireRequest) -> Product:
        # Validate business rules with Rune
        validated = ValidatedCreateProduct.parse({"name": request.name})
        return self._repo.create(validated.name)
```

## Transmute → Enchant Integration

When Enchant models change (new fields, renamed columns), Transmute handles the schema migration:

```python
# Enchant v1: Product has 'name' field
# Enchant v2: Product has 'name' + 'description' field

# Transmute migration
class AddProductDescription(Migration[ProductV1, ProductV2]):
    meta = MigrationMeta(
        id="add-product-description",
        schema_version=2,
        source_version=Version("1.0.0"),
        target_version=Version("1.1.0"),
    )

    def schema_additions(self):
        self.context.execute(
            "ALTER TABLE products ADD COLUMN IF NOT EXISTS description TEXT"
        )

    def rollback(self):
        self.context.execute(
            "ALTER TABLE products DROP COLUMN IF EXISTS description"
        )
```

### Dual-write proxy with generated code

Transmute's `MigrationAwareProxy` routes reads/writes based on migration state:

```python
from transmute import MigrationAwareProxy, Read, Write, WriteStrategy

# Old implementation uses Enchant v1 models
# New implementation uses Enchant v2 models
proxy = MigrationAwareProxy.wrap(
    interface=CatalogRepository,
    old_impl=CatalogRepoV1(),
    new_impl=CatalogRepoV2(),
    migration_id="add-product-description",
    state_provider=storage,
)

# During RUNNING state: reads from old, writes to both
# After FINISHING: reads and writes from new only
```

## Cherry Observability Stack

Cherry provides the observability layer for the entire service:

```
Cherry Server
  ├── Structured logging (8 Conjure-spec loggers)
  │   ├── svc1log: application events
  │   ├── req2log: request/response pairs (auto-logged)
  │   ├── audit3log: user actions requiring audit trail
  │   └── metric1log: periodic metric snapshots
  ├── Distributed tracing (B3/Zipkin)
  │   ├── Root span from incoming request
  │   ├── Child spans for DB queries, external calls
  │   └── Propagated to downstream via enchant-dialogue
  ├── Health checks (7 states)
  │   ├── DATABASE component
  │   ├── EXTERNAL_API component
  │   └── MIGRATION component (Transmute state)
  └── Metrics (5 types)
      ├── request duration/count (auto)
      ├── migration progress (Transmute signals)
      └── custom business metrics
```

## Data Flow Architecture

```
Client Request
  → EnchantChannel (AIMD, retry, safety)
    → Cherry Server (TLS, middleware chain)
      → Enchant error handler middleware
        → Route middleware (span, metrics, req2log)
          → Generated server stub (param extraction, deserialization)
            → Your implementation
              → Rune validation (.parse() / .validate())
                → Repository (Transmute dual-write proxy)
                  → Database
```

## Dependency Graph

```
enchant-dialogue (client runtime)
  ├── httpx
  ├── cattrs
  └── structlog

enchant (code generation, build-time only)
  ├── attrs + cattrs (generated models)
  └── pyyaml (DSL parsing)

cherry (py-witchcraft-server)
  ├── cherrypy
  ├── structlog
  ├── attrs + cattrs (enchant integration)
  └── cryptography (TLS)

rune (validation)
  ├── attrs + cattrs
  └── jsonschema (optional)

transmute (migration)
  ├── attrs + cattrs
  ├── networkx (DAG)
  ├── semantic-version
  └── sqlalchemy (storage backend)
```
